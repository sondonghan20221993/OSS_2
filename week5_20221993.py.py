# -*- coding: utf-8 -*-
"""week5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mPaBThQG_G5E_EmkjadZrz19T03g3IoD
"""

DIAL_CODES = [
    (86, 'China'),
    (91, 'India'),
    (1, 'United States'),
    (55, 'Brazil'),
    (7, 'Russia'),
]

country_code = {country: code for code, country in DIAL_CODES}
country_code

{code: country.upper() for country, code in country_code.items()}

import sys, re

WORD_RE = re.compile(r'\w+')
index = {}

with open("sejong.txt", encoding = 'utf-8') as fp:
    for line_no, line in enumerate(fp, 1):
        for match in WORD_RE.finditer(line):
            word = match.group()
            column_no = match.start()+1
            location = (line_no, column_no)
            occurence = index.get(word, [])
            occurence.append(location)
            index[word] = occurence

for word in sorted(index, key=str.upper):
    print(word, index[word])

import sys, re
WORD_RE = re.compile(r'\w+')
index = {}

with open("sejong.txt", encoding = 'utf-8') as fp:
    for line_no, line in enumerate(fp, 1):
        for match in WORD_RE.finditer(line):
            word = match.group()
            column_no = match.start()+1
            location = (line_no, column_no)
            index.setdefault(word, []).append(location)

for word in sorted(index, key=str.upper):
    print(word, index[word])

import sys, re, collections

WORD_RE = re.compile(r'\w+')

index = collections.defaultdict(list)

with open("sejong.txt", encoding='utf-8') as fp:
    for line_no, line in enumerate(fp, 1):
        for match in WORD_RE.finditer(line):
            word = match.group()
            column_no = match.start()+1
            location = (line_no, column_no)
            index[word].append(location)

for word in sorted(index, key=str.upper):
    print(word, index[word])

class StrKeyDict0(dict):
    # dict 상속

    def __missing__(self, key):
        """
            isinstance 가 없으면 __missing__() 메서드를 재귀적으로 호출
        """
        if isinstance(key, str):
            #키가 문자열인지 확인, 존재하지않으면 에러 keyError발생
            raise KeyError(key)
        return self[str(key)] # 키에서 문자열 만들고 조회
    def get(self, key, default=None):
        """
        get() 메서드는 self[key] 표기법을 이용, __getitem__() 메서드에 위임
        키가 없으면 __missing__() 메서드가 작동할 수 있게 함
        """

        try:
            return self[key]
        except KeyError:
            #KeyError가 발생하면 __missing__() 메서드 실패 -> default반환
            return default

    def __contains__(self, key):
        #'key in self':재귀적으로 __contains__() 호출
        # 수정하지 않은 키 (문자열이 아닐 수 있는)를 검색 후, 키에서 만든 문자열로 검색
        return key in self.keys() or str(key) in self.keys()

d = StrKeyDict0([('2', 'two'),('4', 'four')])
d['2']

d[4]

d.get('2')

d.get(4)

d.get(1, 'N/A')

2 in d

d[1]

import builtins
from collections import ChainMap
pylookup = ChainMap(locals(), globals(), vars(builtins))

ct = collections.Counter('abracadabra')
ct

ct.update('aaaaazzz')
ct

ct.most_common(2)

class StrKeyDict(collections.UserDict):
    def __missing__(self, key):
        if isinstance(key, str):
            raise KeyError(key)
        return self[str(key)]

    def __contains__(self, key):
        return str(key) in self.data

    def __setitem__(self, key, item):
        self.data[str(key)] = item

from types import MappingProxyType
d = {1:'A'}
d_proxy = MappingProxyType(d)

d_proxy

d_proxy[1]

d_proxy[2] = 'x'

d[2] = 'B'
d_proxy

l = ["spam", "spam", "eggs", "spam"]
set(l)

list(set(l))

l = set(["spam", "spam", "eggs", "spam", "eggs", "meats", "onions", "onions"])
m = set(["eggs", "onions"])

found = len(l & m)
found

found = 0
for n in m:
    if n in l:
        found += 1
found

found = len(l.intersection(m))
found

s = {1}
print(type(s))
print(s)

s.pop()
print(s)

from unicodedata import name
{chr(i) for i in range(32,356) if 'SIGN' in name(chr(i),'')}

found = 0
for n in m:
    if n in l:
        found +=1
found

found = len(l & m)
found

DIAL_CODES= [
    (82, 'Korea'),
    (91, 'India'),
    (1, 'United States'),
    (92, 'Pakistan'),
    (7, 'Russia'),
]

#인구가 많은 순서대로 정렬된 튜플 생성
d1 = dict(DIAL_CODES)
print(f'd1: {d1.keys()}')
#국제전화 코드로 정렬된 튜플 생성
d2 = dict(sorted(DIAL_CODES))
print(f'd2: {d2.keys()}')
#국가명으로 정렬된 튜플 생성
d3 = dict(sorted(DIAL_CODES, key=lambda x:x[1]))
print(f'd3: {d3.keys()}')

assert d1 == d2 and d2 == d3
# 딕셔너리가 모두 동일한 키-값 쌍을 갖고 있음을 판단